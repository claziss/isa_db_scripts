<%
  require 'rubygems'
load 'init.rb'

def to_hex(v)
  "0x%08X" % v.to_i(2)
end

def condition(inst)
  ret = []
  inst.conditional_cpu_instruction_relations.each do |rel|
    case rel.cpu_version.name
    when "600"
      ret <<= "ARC_OPCODE_ARC600"
    when "700"
      ret <<= "ARC_OPCODE_ARC700"
    when "arcv2em 1.1"
      ret <<= "ARC_OPCODE_ARCv2EM"
    when "arcv2hs 1.1"
      ret <<= "ARC_OPCODE_ARCv2HS"
    end # The rest are ignored
  end

  ret = ["0"] if (ret.count == 0)
  return ret.join(' | ')
end

def operands(inst)

  # Rename the operand name
  ret = inst.instruction_operands.map { |o| o.assembler_name }

  # Append "dup" to the operand if it is used more than once
  repeated = []
  ret = ret.map do |op|
    if(repeated.find_index(op) != nil)
      op = "#{op}dup"
    end
    repeated <<= op
    op
  end
  return ret.join(', ')
end

def full_mnemonic(inst)
  mnemonic_flags = inst.instruction_flags.map { |f| f.mnemonic_patch }
  mnemonic_operands = inst.instruction_operands.map { |f| f.operand_type.name }
  "#{inst.mnemonic.downcase}#{mnemonic_flags.join('')} #{mnemonic_operands.join(',')}"
end

def flag(insn)
  ret = insn.instruction_flags.map do |o| 
    nme = o.assembler_name
    flpz = 0
    flpz = insn.opcode.index('a') if (nme =~ /C_AA/)
    flpz = insn.opcode.index('Z') if (nme =~ /C_ZZ/)
    flpz = insn.opcode.index('D') if (nme =~ /C_DI/)
    flpz = insn.opcode.index('X') if (nme =~ /C_X/)
    nme = "#{nme}#{flpz}" if (flpz != 0)
    nme
  end
  ret = ["0"] if (insn.instruction_flags.count == 0)
  return ret.join(', ')
end
 #Instruction.all(:order => [:mnemonic.asc]).each do |inst| 
 Instruction.sort.each do |inst| %>
/* <%= full_mnemonic(inst) %> <%= inst.opcode %> */
{ "<%= inst.mnemonic.downcase %>", <%= to_hex(inst.fixed_opcode) %>, <%= to_hex(inst.mask) %>, <%= condition(inst) %>, { <%= operands(inst) %> }, { <%= flag(inst) %> }},
<% end %>
